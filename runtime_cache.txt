% SYS_INIT_PROC v2.7.1b | BUILD 9281
// Session UID: {9B1D8C7A-0E3F-4A9C-82C5-6F7B1A2D3E4F}
# Timestamp: 20251020111938_PKT_CORE
/*
 * Module: runtime_exec_service
 * Auto-generated header. Do not edit.
 * Modifications will be overwritten on next boot cycle.
 * Integrity checksum: f4c3b0a1d9e8f7a6c5b4d3e2f1a0b9c8
 */

// Loading dependencies...
#require "sys_kernel32.dll"
#require "io_stream_drv.sys"
#include <auth_module.h>

@node_alloc=dynamic
@mem_map_flag=0x00A3
@thread_priority=high

[core_params]
load_addr=0xFFFE1000
stack_size=2048
io_mode=async
exec_timeout=5000

// WARNING: Legacy hooks detected. Performance may be degraded.
// Log entry @ 11:19:38 - initializing buffer pool.

func __init_kernel_proc(stream, flags):
    // Bind to parent process
    if !stream.bind(flags):
        throw_err("E_FATAL: Stream bind failed");
    end
end

__BEGIN_PAYLOAD_SECTION__


% SYS_INIT_PROC v2.7.1b | BUILD 9281
// Session UID: {9B1D8C7A-0E3F-4A9C-82C5-6F7B1A2D3E4F}
# Timestamp: 20251020111938_PKT_CORE
/*
 * Module: runtime_exec_service
 * Auto-generated header. Do not edit.
 * Modifications will be overwritten on next boot cycle.
 * Integrity checksum: f4c3b0a1d9e8f7a6c5b4d3e2f1a0b9c8
 */

// Loading dependencies...
#require "sys_kernel32.dll"
#require "io_stream_drv.sys"
#include <auth_module.h>

@node_alloc=dynamic
@mem_map_flag=0x00A3
@thread_priority=high

[core_params]
load_addr=0xFFFE1000
stack_size=2048
io_mode=async
exec_timeout=5000

// WARNING: Legacy hooks detected. Performance may be degraded.
// Log entry @ 11:19:38 - initializing buffer pool.

func __init_kernel_proc(stream, flags):
    // Bind to parent process
    if !stream.bind(flags):
        throw_err("E_FATAL: Stream bind failed");
    end
end

__BEGIN_PAYLOAD_SECTION__



% SYS_INIT_PROC v2.7.1b | BUILD 9281
// Session UID: {9B1D8C7A-0E3F-4A9C-82C5-6F7B1A2D3E4F}
# Timestamp: 20251020111938_PKT_CORE
/*
 * Module: runtime_exec_service
 * Auto-generated header. Do not edit.
 * Modifications will be overwritten on next boot cycle.
 * Integrity checksum: f4c3b0a1d9e8f7a6c5b4d3e2f1a0b9c8
 */

// Loading dependencies...
#require "sys_kernel32.dll"
#require "io_stream_drv.sys"
#include <auth_module.h>

@node_alloc=dynamic
@mem_map_flag=0x00A3
@thread_priority=high

[core_params]
load_addr=0xFFFE1000
stack_size=2048
io_mode=async
exec_timeout=5000

// WARNING: Legacy hooks detected. Performance may be degraded.
// Log entry @ 11:19:38 - initializing buffer pool.

func __init_kernel_proc(stream, flags):
    // Bind to parent process
    if !stream.bind(flags):
        throw_err("E_FATAL: Stream bind failed");
    end
end

__BEGIN_PAYLOAD_SECTION__



% SYS_INIT_PROC v2.7.1b | BUILD 9281
// Session UID: {9B1D8C7A-0E3F-4A9C-82C5-6F7B1A2D3E4F}
# Timestamp: 20251020111938_PKT_CORE
/*
 * Module: runtime_exec_service
 * Auto-generated header. Do not edit.
 * Modifications will be overwritten on next boot cycle.
 * Integrity checksum: f4c3b0a1d9e8f7a6c5b4d3e2f1a0b9c8
 */

// Loading dependencies...
#require "sys_kernel32.dll"
#require "io_stream_drv.sys"
#include <auth_module.h>

@node_alloc=dynamic
@mem_map_flag=0x00A3
@thread_priority=high

[core_params]
load_addr=0xFFFE1000
stack_size=2048
io_mode=async
exec_timeout=5000

// WARNING: Legacy hooks detected. Performance may be degraded.
// Log entry @ 11:19:38 - initializing buffer pool.

func __init_kernel_proc(stream, flags):
    // Bind to parent process
    if !stream.bind(flags):
        throw_err("E_FATAL: Stream bind failed");
    end
end

__BEGIN_PAYLOAD_SECTION__



% SYS_INIT_PROC v2.7.1b | BUILD 9281
// Session UID: {9B1D8C7A-0E3F-4A9C-82C5-6F7B1A2D3E4F}
# Timestamp: 20251020111938_PKT_CORE

 * Modifications will be overwritten on next boot cycle.
 * Integrity checksum: f4c3b0a1d9e8f7a6c5b4d3e2f1a0b9c8
 */

// Loading dependencies...
#require "sys_kernel32.dll"
#require "io_stream_drv.sys"
#include <auth_module.h>

@node_alloc=dynamic
@mem_map_flag=0x00A3
@thread_priority=high

[core_params]
load_addr=0xFFFE1000
stack_size=2048
io_mode=async
exec_timeout=5000

// WARNING: Legacy hooks detected. Performance may be degraded.
// Log entry @ 11:19:38 - initializing buffer pool.

func __init_kernel_proc(stream, flags):
    // Bind to parent process
    if !stream.bind(flags):
        throw_err("E_FATAL: Stream bind failed");
    end
end

__BEGIN_PAYLOAD_SECTION__































% #######################################################################
% #                              LAB 1 CODE                             #
% #      (Symbolic Calculus & Sequence Convergence)                     #
% #######################################################################

% Task 1: Limit Evaluation (lim(x->inf)(1+1/x)^x)
syms x
f = (1 + 1/x)^x;
L = limit(f, x, inf);
double(L)

% Task 2: Differentiation (d/dx(e^(2x) + sin(x)))
syms x
f = exp(2*x) + sin(x);
df = diff(f, x);
disp('The derivative is:');
disp(df);

% Task 3: Integration (int(0 to pi) sin(x) dx)
syms x
f = sin(x);
I = int(f, x, 0, pi);
double(I)

% Task 4: Convergent Sequence (x_(n+1) = x_n/2)
% Parameters
x0 = 4;
N = 12; % I have randomly assumed number of iterations
x = zeros(1, N+1);
x(1) = x0;
for n = 1:N
    x(n+1) = x(n)/2;
end
% Displaying the sequence
disp(x)

% Task 5: Divergent Sequence (x_(n+1) = 2x_n)
% Parameters
x0 = 1;
N = 10;
x = zeros(1, N+1);
x(1) = x0;
for n = 1:N
    x(n+1) = 2*x(n);
end
disp(x)
%plotting
n = 0:N;
figure;
stem(n, x, 'filled');
xlabel('n'); ylabel('x_n');
title('Iteration: x_{n+1}=2x_n');
grid on;

% #######################################################################
% #                              LAB 2 CODE                             #
% #                     (Bisection Method)                              #
% #######################################################################

% Bisection Method Function Definition (Used across all tasks)
function root = bisection_method(f, a, b, tol, max_iter)
    if f(a)*f(b) > 0
        error('f(a) and f(b) must have opposite signs');
    end
    for i = 1:max_iter
        c = (a+b)/2; % Midpoint
        fc = f(c);
        if abs(fc) < tol || (b-a)/2 < tol
            root = c;
            fprintf('Root found at x = %.6f after %d iterations\n', c, i);
            return;
        end
        if f(a)*fc < 0
            b = c;
        else
            a = c;
        end
    end
    root = (a+b)/2;
end

% Task 1: Root of a Quadratic Function (x^2 - 25)
f = @(x) x.^2 - 25;
a = 0;
b = 10;
tol = 1e-4;
max_iter = 100;
root = bisection_method(f, a, b, tol, max_iter);

% Task 2: Root of a Trigonometric Equation (sin(x) - 0.5)
f = @(x) sin(x) - 0.5;
a = 0;
b = 2;
tol = 1e-4;
max_iter = 100;
root = bisection_method(f, a, b, tol, max_iter);

% Task 3: Root of a Cubic Function (x^3 - 2x - 5)
f = @(x) x.^3 - 2*x - 5;
a = 2;
b = 3;
tol = 1e-4;
max_iter = 100;
root = bisection_method(f, a, b, tol, max_iter);

% Task 4: Exponential Equation (exp(x) - 3)
f = @(x) exp(x) - 3;
a = 0;
b = 2;
tol = 1e-4;
max_iter = 100;
root = bisection_method(f, a, b, tol, max_iter);

% #######################################################################
% #                              LAB 3 CODE                             #
% #                   (Fixed-Point Iteration)                           #
% #######################################################################

% Fixed Point Iteration Method Code (Used across all tasks)
g = input('Enter your function: ');
x0 = input('Enter initial guess value: ');
e = input('Tolerance value: ');
n = input('Number of iterations: ');

for i = 1:n
    x1 = g(x0); % Apply g(x)
    fprintf('x%d = %.6f\n', i, x1);
    
    if abs(x1 - x0) < e
        break;
    end
    
    x0 = x1;
end

% Task 4 Discussion Line (from Task 4 code block)
%Some initial guesses converge faster because the slope of g(x) near the root is smaller, making convergence quicker


% #######################################################################
% #                              LAB 4 CODE                             #
% #                   (Newton-Raphson Method)                           #
% #######################################################################

% Task 1: f(x) = exp(x) - 3x
clear;
close all;
clc;
f = @(x) exp(x) - 3*x;
df = @(x) exp(x) - 3;
x0 = 0.5;
e = 1e-5;
n = 20;
if df(x0) ~= 0
    for i = 1:n
        x1 = x0 - f(x0)/df(x0);
        fprintf('Iteration %d: x1=%.6f\n', i, x1);
        if abs(x1 - x0) < e
            break;
        end
        x0 = x1;
    end
else
    error('Derivative is zero; Newton''s method cannot proceed.');
end

% Task 2: f(x) = x^3 - 2x - 5
clear; close all; clc;
f = @(x) x^3 - 2*x - 5;
df = @(x) 3*x^2 - 2;
x0 = 2;
e = 1e-6;
n = 30;
if df(x0) ~= 0
    for i = 1:n
        x1 = x0 - f(x0)/df(x0);
        fprintf('Iteration %d: x1=%.6f\n', i, x1);
        if abs(x1 - x0) < e
            break;
        end
        x0 = x1;
    end
else
    error('Derivative is zero; Newton''s method cannot proceed.');
end

% Task 3: f(x) = cos(x) - x
clear; close all; clc;
f = @(x) cos(x) - x;
df = @(x) -sin(x) - 1;
x0 = 1;
e = 1e-7;
n = 50;
if df(x0) ~= 0
    for i = 1:n
        x1 = x0 - f(x0)/df(x0);
        fprintf('Iteration %d: x1=%.6f\n', i, x1);
        if abs(x1 - x0) < e
            break;
        end
        x0 = x1;
    end
else
    error('Derivative is zero; Newton''s method cannot proceed.');
end

% Task 4: f(x) = x*exp(x) - 1
clear; close all; clc;
f = @(x) x*exp(x) - 1;
df = @(x) exp(x).*(1+x);
x0 = 0.5;
e = 1e-8;
n = 50;
if df(x0) ~= 0
    for i = 1:n
        x1 = x0 - f(x0)/df(x0);
        fprintf('Iteration %d: x1=%.6f\n', i, x1);
        if abs(x1 - x0) < e
            break;
        end
        x0 = x1;
    end
else
    error('Derivative is zero; Newton''s method cannot proceed.');
end

% Task 5: f(x) = x^4 + x - 10
clear; close all; clc;
f = @(x) x^4 + x - 10;
df = @(x) 4*x^3 + 1;
x0 = 1.5;
e = 1e-10;
n = 100;
if df(x0) ~= 0
    for i = 1:n
        x1 = x0 - f(x0)/df(x0);
        fprintf('Iteration %d: x1=%.6f\n', i, x1);
        if abs(x1 - x0) < e
            break;
        end
        x0 = x1;
    end
else
    error('Derivative is zero; Newton''s method cannot proceed.');
end


% #######################################################################
% #                              LAB 5 CODE                             #
% #                     (Lagrange Interpolation)                        #
% #######################################################################

% Task 1: Lagrange Interpolation for (1,3),(2,6),(3,11)
x = [1 2 3];
y = [3 6 11];
syms X
P = 0;
% Lagrange interpolation formula
for i = 1:length(x)
    L = 1;
    for j = 1:length(x)
        if j ~= i
            L = L * (X - x(j)) / (x(i) - x(j));
        end
    end
    P = P + y(i) * L;
end
P = simplify(P); % Simplify the polynomial
% Find estimated value at x=2.5
Y_at_2_5 = double(subs(P, X, 2.5));
fprintf('Interpolating Polynomial: %s\n', char(P));
fprintf('Estimated value of y at x=2.5: %.2f\n', Y_at_2_5);
% Plotting code starts here (reduced for single block)
x_plot = linspace(1, 3, 100); 
y_interp = double(subs(P, X, x_plot));
figure;
plot(x_plot, y_interp, 'r--', 'LineWidth', 1.5); hold on;
plot(x, y, 'ko', 'MarkerFaceColor', 'k'); 
plot(2.5, Y_at_2_5, 'ms', 'MarkerFaceColor', 'm'); 
legend('Lagrange Interpolating Polynomial', 'Given Data Points', 'Estimated Value at x=2.5', 'Location', 'northwest');
xlabel('x'); ylabel('y'); title('Lagrange Interpolation for Given Data Points'); grid on;

% Task 2: Lagrange Interpolation for f(x)=x^2+2x+1
x = [0 1 2];
y = x.^2 + 2.*x + 1;
syms X
P = 0;
for i = 1:length(x)
    L = 1;
    for j = 1:length(x)
        if j ~= i
            L = L * (X - x(j)) / (x(i) - x(j));
        end
    end
    P = P + y(i) * L;
end
P = simplify(P);
Y_interp = double(subs(P, X, 1.5));
f_actual = (1.5)^2 + 2*(1.5) + 1;
fprintf('Interpolating Polynomial: %s\n', char(P));
fprintf('Estimated f(1.5) using interpolation: %.4f\n', Y_interp);
fprintf('Actual f(1.5): %.4f\n', f_actual);
fprintf('Difference: %.4e\n', abs(f_actual - Y_interp));
f = @(x) x.^2 + 2.*x + 1; 
x_plot = linspace(0, 2, 100); 
y_actual = f(x_plot);
y_interp = double(subs(P, X, x_plot));
figure;
plot(x_plot, y_actual, 'b', 'LineWidth', 1.5); hold on; 
plot(x_plot, y_interp, 'r--', 'LineWidth', 1.5); 
plot(x, y, 'ko', 'MarkerFaceColor', 'k');
plot(1.5, Y_interp, 'ms', 'MarkerFaceColor', 'm'); 
legend('Actual Function f(x)', 'Lagrange Interpolation', 'Given Points', 'Estimated f(1.5)', 'Location', 'northwest');
xlabel('x'); ylabel('y'); title('Lagrange Interpolation vs Actual Function'); grid on;

% Task 3: Lagrange Interpolation for [0,2,4,6] and [1,5,17,37]
x = [0 2 4 6];
y = [1 5 17 37];
x_interp = 3;
y_interp = 0;
n = length(x);
% 1. Estimation Loop (y_interp at x=3)
for i = 1:n
    L = 1;
    for j = 1:n
        if j ~= i
            L = L * (x_interp - x(j)) / (x(i) - x(j));
        end
    end
    y_interp = y_interp + L * y(i);
end
fprintf('Estimated value of y at x=%.1f is %.3f\n', x_interp, y_interp);
% 2. Plotting Loop (y_fine for the curve)
x_fine = linspace(min(x), max(x), 200);
y_fine = zeros(size(x_fine));
for k = 1:length(x_fine)
    sumL = 0;
    for i = 1:n
        L = 1;
        for j = 1:n
            if j ~= i
                L = L * (x_fine(k) - x(j)) / (x(i) - x(j));
            end
        end
        sumL = sumL + L * y(i);
    end
    y_fine(k) = sumL;
end
figure;
plot(x, y, 'ro', 'MarkerFaceColor', 'r', 'DisplayName', 'Given Points');
hold on;
plot(x_fine, y_fine, 'b', 'LineWidth', 1.5, 'DisplayName', 'Interpolated Curve');
plot(x_interp, y_interp, 'ks', 'MarkerFaceColor', 'g', 'DisplayName', 'Estimated Point');
xlabel('x'); ylabel('y'); title('Lagrange Interpolation Polynomial'); legend('Location', 'best'); grid on;

% Task 4: Temperature Data Interpolation
t = [0 2 5 7]; 
T = [10 15 25 30]; 
t_interp = 4;
T_interp = 0;
n = length(t);
% 1. Estimation Loop (T_interp at t=4)
for i = 1:n
    L = 1;
    for j = 1:n
        if j ~= i
            L = L * (t_interp - t(j)) / (t(i) - t(j));
        end
    end
    T_interp = T_interp + L * T(i);
end
fprintf('Estimated Temperature at t=%.1f s is %.3f°C\n', t_interp, T_interp);
% 2. Plotting Loop (T_fine for the curve)
t_fine = linspace(min(t), max(t), 100);
T_fine = zeros(size(t_fine));
for k = 1:length(t_fine)
    sumL = 0;
    for i = 1:n
        L = 1;
        for j = 1:n
            if j ~= i
                L = L * (t_fine(k) - t(j)) / (t(i) - t(j));
            end
        end
        sumL = sumL + L * T(i);
    end
    T_fine(k) = sumL;
end
figure;
plot(t, T, 'ro', 'MarkerFaceColor', 'r', 'DisplayName', 'Given Points');
hold on;
plot(t_fine, T_fine, 'b', 'LineWidth', 1.5, 'DisplayName', 'Interpolated Curve');
plot(t_interp, T_interp, 'ks', 'MarkerFaceColor', 'g', 'DisplayName', 'Estimated Point');
xlabel('Time (s)'); ylabel('Temperature (°C)'); title('Lagrange Interpolation of Temperature Data'); legend('Location', 'best'); grid on;





















